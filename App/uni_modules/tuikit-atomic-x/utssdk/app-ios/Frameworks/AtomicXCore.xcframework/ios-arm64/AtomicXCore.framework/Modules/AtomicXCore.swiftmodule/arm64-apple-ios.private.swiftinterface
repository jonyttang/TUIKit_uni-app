// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.0.3 effective-5.10 (swiftlang-6.0.3.1.10 clang-1600.0.30.1)
// swift-module-flags: -target arm64-apple-ios14.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name AtomicXCore
// swift-module-flags-ignorable: -no-verify-emitted-module-interface
import AVFoundation
@_exported import AtomicXCore
import Combine
import Foundation
import ImSDK_Plus
import RTCRoomEngine
import Swift
import SwiftUI
import TXLiteAVSDK_Professional
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum AudioChangerType : Swift.Int {
  case none
  case child
  case littleGirl
  case man
  case heavyMetal
  case cold
  case foreigner
  case trappedBeast
  case fatso
  case strongCurrent
  case heavyMachinery
  case ethereal
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum AudioReverbType : Swift.Int {
  case none
  case ktv
  case smallRoom
  case auditorium
  case deep
  case loud
  case metallic
  case magnetic
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct AudioEffectState {
  public var audioChangerType: AtomicXCore.AudioChangerType
  public var audioReverbType: AtomicXCore.AudioReverbType
  public var isEarMonitorOpened: Swift.Bool
  public var earMonitorVolume: Swift.Int
  public init()
}
@_hasMissingDesignatedInitializers public class AudioEffectStore {
  public static let shared: AtomicXCore.AudioEffectStore
  public var state: AtomicXCore.StatePublisher<AtomicXCore.AudioEffectState> {
    get
  }
  public func setAudioChangerType(type: AtomicXCore.AudioChangerType)
  public func setAudioReverbType(type: AtomicXCore.AudioReverbType)
  public func setVoiceEarMonitorEnable(enable: Swift.Bool)
  public func setVoiceEarMonitorVolume(volume: Swift.Int)
  public func reset()
  @objc deinit
}
public enum BarrageType : Swift.Int {
  case text
  case custom
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct Barrage {
  public var liveID: Swift.String
  public var sender: AtomicXCore.LiveUserInfo
  public var sequence: Swift.Int
  public var timestampInSecond: Swift.Double
  public var messageType: AtomicXCore.BarrageType
  public var textContent: Swift.String
  public var extensionInfo: [Swift.String : Swift.String]?
  public var businessID: Swift.String
  public var data: Swift.String
  public init()
}
public struct BarrageState {
  public var messageList: [AtomicXCore.Barrage]
  public init()
}
@_hasMissingDesignatedInitializers public class BarrageStore {
  public static func create(liveID: Swift.String) -> AtomicXCore.BarrageStore
  public var state: AtomicXCore.StatePublisher<AtomicXCore.BarrageState> {
    get
  }
  public func sendTextMessage(text: Swift.String, extensionInfo: [Swift.String : Swift.String]?, completion: AtomicXCore.CompletionClosure?)
  public func sendCustomMessage(businessID: Swift.String, data: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func appendLocalTip(message: AtomicXCore.Barrage)
  @objc deinit
}
public struct BaseBeautyState {
  public var smoothLevel: Swift.Float
  public var whitenessLevel: Swift.Float
  public var ruddyLevel: Swift.Float
  public init()
}
@_hasMissingDesignatedInitializers public class BaseBeautyStore {
  public static let shared: AtomicXCore.BaseBeautyStore
  public var state: AtomicXCore.StatePublisher<AtomicXCore.BaseBeautyState> {
    get
  }
  public func setSmoothLevel(smoothLevel: Swift.Float)
  public func setWhitenessLevel(whitenessLevel: Swift.Float)
  public func setRuddyLevel(ruddyLevel: Swift.Float)
  public func reset()
  @objc deinit
}
public struct BattleConfig {
  public var duration: Foundation.TimeInterval
  public var needResponse: Swift.Bool
  public var extensionInfo: Swift.String
}
public struct BattleInfo {
  public var battleID: Swift.String
  public var config: AtomicXCore.BattleConfig
  public var startTime: Swift.UInt
  public var endTime: Swift.UInt
}
public enum BattleEndedReason : Swift.Int {
  case timeOver
  case allMemberExit
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BattleEvent {
  case onBattleStarted(battleInfo: AtomicXCore.BattleInfo, inviter: AtomicXCore.SeatUserInfo, invitees: [AtomicXCore.SeatUserInfo])
  case onBattleEnded(battleInfo: AtomicXCore.BattleInfo, reason: AtomicXCore.BattleEndedReason)
  case onUserJoinBattle(battleID: Swift.String, battleUser: AtomicXCore.SeatUserInfo)
  case onUserExitBattle(battleID: Swift.String, battleUser: AtomicXCore.SeatUserInfo)
  case onBattleRequestReceived(battleID: Swift.String, inviter: AtomicXCore.SeatUserInfo, invitee: AtomicXCore.SeatUserInfo)
  case onBattleRequestCancelled(battleID: Swift.String, inviter: AtomicXCore.SeatUserInfo, invitee: AtomicXCore.SeatUserInfo)
  case onBattleRequestTimeout(battleID: Swift.String, inviter: AtomicXCore.SeatUserInfo, invitee: AtomicXCore.SeatUserInfo)
  case onBattleRequestAccept(battleID: Swift.String, inviter: AtomicXCore.SeatUserInfo, invitee: AtomicXCore.SeatUserInfo)
  case onBattleRequestReject(battleID: Swift.String, inviter: AtomicXCore.SeatUserInfo, invitee: AtomicXCore.SeatUserInfo)
}
public typealias BattleRequestClosure = (Swift.Result<(AtomicXCore.BattleInfo, [Swift.String : Swift.Int]), AtomicXCore.ErrorInfo>) -> Swift.Void
public struct BattleState : AtomicXCore.CoreViewState {
  public var currentBattleInfo: AtomicXCore.BattleInfo?
  public var battleUsers: [AtomicXCore.SeatUserInfo]
  public var battleScore: [Swift.String : Swift.UInt]
  @available(*, deprecated)
  public var battleId: Swift.String
  @available(*, deprecated)
  public var inviteeList: [RTCRoomEngine.TUIBattleUser]
  @available(*, deprecated)
  public var battlingUserList: [RTCRoomEngine.TUIBattleUser]
  public init()
}
@_hasMissingDesignatedInitializers public class BattleStore {
  public static func create(liveID: Swift.String) -> AtomicXCore.BattleStore
  public var state: AtomicXCore.StatePublisher<AtomicXCore.BattleState> {
    get
  }
  public var battleEventPublisher: Combine.PassthroughSubject<AtomicXCore.BattleEvent, Swift.Never> {
    get
  }
  public func requestBattle(config: AtomicXCore.BattleConfig, userIDList: [Swift.String], timeout: Foundation.TimeInterval, completion: AtomicXCore.BattleRequestClosure?)
  public func cancelBattleRequest(battleId: Swift.String, userIdList: [Swift.String], completion: AtomicXCore.CompletionClosure?)
  public func acceptBattle(battleID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func rejectBattle(battleID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func exitBattle(battleID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
extension AtomicXCore.BattleConfig : Swift.Equatable {
  public static func == (lhs: AtomicXCore.BattleConfig, rhs: AtomicXCore.BattleConfig) -> Swift.Bool
}
extension AtomicXCore.BattleInfo : Swift.Equatable {
  public static func == (lhs: AtomicXCore.BattleInfo, rhs: AtomicXCore.BattleInfo) -> Swift.Bool
}
public struct C2CSettingState {
  public var avatarURL: Swift.String
  public var isNotDisturb: Swift.Bool
  public var isPinned: Swift.Bool
  public var nickname: Swift.String
  public var signature: Swift.String
  public var remark: Swift.String
  public var isContact: Swift.Bool
  public var isInBlacklist: Swift.Bool
}
@objc @_hasMissingDesignatedInitializers public class C2CSettingStore : ObjectiveC.NSObject {
  final public let userID: Swift.String
  public var state: AtomicXCore.StatePublisher<AtomicXCore.C2CSettingState>
  public static func create(userID: Swift.String) -> AtomicXCore.C2CSettingStore
  public func fetchUserInfo(completion: AtomicXCore.CompletionClosure?)
  public func setUserRemark(remark: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func addToBlacklist(completion: AtomicXCore.CompletionClosure?)
  public func removeFromBlacklist(completion: AtomicXCore.CompletionClosure?)
  public func checkBlacklistStatus(completion: AtomicXCore.CompletionClosure?)
  public func deleteFriend(completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ChatUtil {
  public static func dictionary2JsonData(_ dictionary: [Swift.String : Any]) -> Foundation.Data?
  public static func jsonData2Dictionary(jsonData: Foundation.Data?) -> [Swift.String : Any]?
  public static func convertDateToHMStr(_ date: Foundation.Date?) -> Swift.String?
  public static func getHomePath() -> Swift.String
  public static func getMediaHomePath(messageType: AtomicXCore.MessageType) -> Swift.String
  public static func generateMediaPath(messageType: AtomicXCore.MessageType, withExtension: Swift.String?) -> Swift.String
  public static func getUserID(_ conversationID: Swift.String) -> Swift.String?
  public static func getGroupID(_ conversationID: Swift.String) -> Swift.String?
  public static func getC2CConversationID(_ userID: Swift.String) -> Swift.String
  public static func getGroupConversationID(_ userID: Swift.String) -> Swift.String
  public static func getMemberShowName(_ info: ImSDK_Plus.V2TIMGroupMemberInfo?) -> Swift.String
  public static func getMemberShowName(_ tips: ImSDK_Plus.V2TIMGroupTipsElem?, with userId: Swift.String?) -> Swift.String
  public static func getMembersShowName(_ infoList: [ImSDK_Plus.V2TIMGroupMemberInfo]?) -> [Swift.String]
  public static func getMessageSenderName(_ message: ImSDK_Plus.V2TIMMessage?) -> Swift.String
  public static func convertToUIMessage(rawMessage: ImSDK_Plus.V2TIMMessage) -> AtomicXCore.MessageInfo
  public static func getActualMediaPath(_ messageType: AtomicXCore.MessageType, mediaPath: Swift.String?, uuid: Swift.String?, fileExtension: Swift.String?, isLocalExist: inout Swift.Bool) -> Swift.String
  public static func convertToSystemInfoFromRecall(_ message: ImSDK_Plus.V2TIMMessage, operateUser: ImSDK_Plus.V2TIMUserInfo?, reason: Swift.String?) -> AtomicXCore.SystemMessageInfo
  public static func convertToSystemInfoFromGroupInfoChangedList(opUser: Swift.String, userList: [Swift.String], tipsElem: ImSDK_Plus.V2TIMGroupTipsElem) -> [AtomicXCore.SystemMessageInfo]
  @objc deinit
}
public struct CoGuestState : AtomicXCore.CoreViewState {
  public var connected: [AtomicXCore.SeatUserInfo]
  public var invitees: [AtomicXCore.LiveUserInfo]
  public var applicants: [AtomicXCore.LiveUserInfo]
  public var candidates: [AtomicXCore.LiveUserInfo]
  @available(*, deprecated)
  public var seatList: [RTCRoomEngine.TUISeatInfo]
  @available(*, deprecated)
  public var connectedUserList: [RTCRoomEngine.TUIUserInfo]
  @available(*, deprecated)
  public var applicantList: Swift.Set<RTCRoomEngine.TUIUserInfo>
  @available(*, deprecated)
  public var inviteeList: Swift.Set<RTCRoomEngine.TUIUserInfo>
  public init()
}
public enum NoResponseReason : Swift.Int {
  case timeout
  case alreadySeated
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum HostEvent {
  case onGuestApplicationReceived(guestUser: AtomicXCore.LiveUserInfo)
  case onGuestApplicationCancelled(guestUser: AtomicXCore.LiveUserInfo)
  case onGuestApplicationProcessedByOtherHost(guestUser: AtomicXCore.LiveUserInfo, hostUser: AtomicXCore.LiveUserInfo)
  case onHostInvitationResponded(isAccept: Swift.Bool, guestUser: AtomicXCore.LiveUserInfo)
  case onHostInvitationNoResponse(guestUser: AtomicXCore.LiveUserInfo, reason: AtomicXCore.NoResponseReason)
}
public enum GuestEvent {
  case onHostInvitationReceived(hostUser: AtomicXCore.LiveUserInfo)
  case onHostInvitationCancelled(hostUser: AtomicXCore.LiveUserInfo)
  case onGuestApplicationResponded(isAccept: Swift.Bool, hostUser: AtomicXCore.LiveUserInfo)
  case onGuestApplicationNoResponse(reason: AtomicXCore.NoResponseReason)
  case onKickedOffSeat(seatIndex: Swift.Int, hostUser: AtomicXCore.LiveUserInfo)
}
@_hasMissingDesignatedInitializers public class CoGuestStore {
  public static func create(liveID: Swift.String) -> AtomicXCore.CoGuestStore
  final public let state: AtomicXCore.StatePublisher<AtomicXCore.CoGuestState>
  final public let guestEventPublisher: Combine.PassthroughSubject<AtomicXCore.GuestEvent, Swift.Never>
  final public let hostEventPublisher: Combine.PassthroughSubject<AtomicXCore.HostEvent, Swift.Never>
  public func applyForSeat(seatIndex: Swift.Int = -1, timeout: Foundation.TimeInterval, extraInfo: Swift.String?, completion: AtomicXCore.CompletionClosure?)
  public func cancelApplication(completion: AtomicXCore.CompletionClosure?)
  public func acceptApplication(userID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func rejectApplication(userID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func inviteToSeat(userID: Swift.String, seatIndex: Swift.Int = -1, timeout: Foundation.TimeInterval, extraInfo: Swift.String?, completion: AtomicXCore.CompletionClosure?)
  public func cancelInvitation(inviteeID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func acceptInvitation(inviterID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func rejectInvitation(inviterID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func disConnect(completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
public enum CoHostStatus : Swift.Int {
  case connected
  case disconnected
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum CoHostLayoutTemplate : Swift.Int {
  case hostDynamicGrid
  case hostDynamic1v6
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct CoHostState : AtomicXCore.CoreViewState {
  public var coHostStatus: AtomicXCore.CoHostStatus
  public var connected: [AtomicXCore.SeatUserInfo]
  public var invitees: [AtomicXCore.SeatUserInfo]
  public var applicant: AtomicXCore.SeatUserInfo?
  @available(*, deprecated)
  public var connectedUserList: [RTCRoomEngine.TUIConnectionUser]
  @available(*, deprecated)
  public var sentConnectionRequestList: [RTCRoomEngine.TUIConnectionUser]
  @available(*, deprecated)
  public var receivedConnectionRequest: RTCRoomEngine.TUIConnectionUser?
  public init()
}
public enum CoHostEvent {
  case onCoHostRequestReceived(inviter: AtomicXCore.SeatUserInfo, extensionInfo: Swift.String)
  case onCoHostRequestCancelled(inviter: AtomicXCore.SeatUserInfo, invitee: AtomicXCore.SeatUserInfo?)
  case onCoHostRequestAccepted(invitee: AtomicXCore.SeatUserInfo)
  case onCoHostRequestRejected(invitee: AtomicXCore.SeatUserInfo)
  case onCoHostRequestTimeout(inviter: AtomicXCore.SeatUserInfo, invitee: AtomicXCore.SeatUserInfo)
  case onCoHostUserJoined(userInfo: AtomicXCore.SeatUserInfo)
  case onCoHostUserLeft(userInfo: AtomicXCore.SeatUserInfo)
}
@_hasMissingDesignatedInitializers public class CoHostStore {
  public static func create(liveID: Swift.String) -> AtomicXCore.CoHostStore
  final public let state: AtomicXCore.StatePublisher<AtomicXCore.CoHostState>
  final public let coHostEventPublisher: Combine.PassthroughSubject<AtomicXCore.CoHostEvent, Swift.Never>
  public func requestHostConnection(targetHost liveId: Swift.String, layoutTemplate: AtomicXCore.CoHostLayoutTemplate, timeout: Foundation.TimeInterval, extraInfo: Swift.String = "", completion: AtomicXCore.CompletionClosure?)
  public func cancelHostConnection(toHostLiveID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func acceptHostConnection(fromHostLiveID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func rejectHostConnection(fromHostLiveID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func exitHostConnection(completion: AtomicXCore.CompletionClosure? = nil)
  @objc deinit
}
public enum ContactOnlineStatus : Swift.UInt {
  case unknown
  case online
  case offline
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public enum ContactType : Swift.UInt {
  case unknown
  case user
  case group
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public enum FriendApplicationType : Swift.Int {
  case received
  case sent
  case both
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum GroupApplicationType : Swift.Int {
  case joinApprovedByAdmin
  case inviteApprovedByInvitee
  case inviteApprovedByAdmin
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum GroupApplicationHandledStatus : Swift.Int {
  case unhandled
  case byOther
  case byMyself
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum GroupApplicationHandledResult : Swift.Int {
  case refused
  case agreed
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct ContactInfo : Swift.Identifiable, Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public var contactID: Swift.String
  public var type: AtomicXCore.ContactType?
  public var avatarURL: Swift.String?
  public var title: Swift.String?
  public var onlineStatus: AtomicXCore.ContactOnlineStatus
  public var isContact: Swift.Bool
  public var isInGroup: Swift.Bool
  public init(identifier: Swift.String, avatarURL: Swift.String? = "", title: Swift.String? = "")
  public static func == (a: AtomicXCore.ContactInfo, b: AtomicXCore.ContactInfo) -> Swift.Bool
  public typealias ID = Swift.String
}
public struct FriendApplicationInfo : Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public var applicationID: Swift.String
  public var avatarURL: Swift.String?
  public var title: Swift.String?
  public var source: Swift.String?
  public var type: AtomicXCore.FriendApplicationType
  public var addWording: Swift.String?
  public typealias ID = Swift.String
}
public struct GroupApplicationInfo : Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public var applicationID: Swift.String
  public var groupID: Swift.String
  public var fromUser: Swift.String?
  public var fromUserNickname: Swift.String?
  public var fromUserAvatarURL: Swift.String?
  public var toUser: Swift.String?
  public var addTime: Swift.UInt
  public var requestMsg: Swift.String?
  public var handledMsg: Swift.String?
  public var type: AtomicXCore.GroupApplicationType
  public var handledStatus: AtomicXCore.GroupApplicationHandledStatus?
  public var handledResult: AtomicXCore.GroupApplicationHandledResult?
  public typealias ID = Swift.String
}
public struct ContactListState {
  public var blackList: [AtomicXCore.ContactInfo]
  public var friendList: [AtomicXCore.ContactInfo]
  public var groupList: [AtomicXCore.ContactInfo]
  public var friendApplicationList: [AtomicXCore.FriendApplicationInfo]
  public var friendApplicationUnreadCount: Swift.Int
  public var groupApplicationList: [AtomicXCore.GroupApplicationInfo]
  public var groupApplicationUnreadCount: Swift.Int
  public var addFriendInfo: AtomicXCore.ContactInfo?
  public var joinGroupInfo: AtomicXCore.ContactInfo?
  public var createdGroupID: Swift.String?
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ContactListStore : ObjectiveC.NSObject {
  public var state: AtomicXCore.StatePublisher<AtomicXCore.ContactListState>
  public static func create() -> AtomicXCore.ContactListStore
  public func fetchJoinedGroupList(completion: AtomicXCore.CompletionClosure?)
  public func fetchFriendList(completion: AtomicXCore.CompletionClosure?)
  public func fetchBlackList(completion: AtomicXCore.CompletionClosure?)
  public func fetchFriendApplicationList(completion: AtomicXCore.CompletionClosure?)
  public func fetchGroupApplicationList(completion: AtomicXCore.CompletionClosure?)
  public func fetchUserInfo(userID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func fetchGroupInfo(groupID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func acceptFriendApplication(info: AtomicXCore.FriendApplicationInfo, completion: AtomicXCore.CompletionClosure?)
  public func refuseFriendApplication(info: AtomicXCore.FriendApplicationInfo, completion: AtomicXCore.CompletionClosure?)
  public func clearFriendApplicationUnreadCount(completion: AtomicXCore.CompletionClosure?)
  public func addFriend(userID: Swift.String, remark: Swift.String?, addWording: Swift.String?, completion: AtomicXCore.CompletionClosure?)
  public func joinGroup(groupID: Swift.String, message: Swift.String?, completion: AtomicXCore.CompletionClosure?)
  public func createGroup(groupType: Swift.String, groupName: Swift.String, groupID: Swift.String?, avatarURL: Swift.String?, memberList: [AtomicXCore.ContactInfo]?, completion: AtomicXCore.CompletionClosure?)
  public func acceptGroupApplication(info: AtomicXCore.GroupApplicationInfo, completion: AtomicXCore.CompletionClosure?)
  public func refuseGroupApplication(info: AtomicXCore.GroupApplicationInfo, completion: AtomicXCore.CompletionClosure?)
  public func clearGroupApplicationUnreadCount(completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
public enum ConversationType : Swift.UInt {
  case unknown
  case c2c
  case group
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public enum ConversationReceiveOption : Swift.Int {
  case receive
  case notReceive
  case notNotify
  case notNotifyExceptMention
  case notReceiveExceptMention
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct ConversationInfo : Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public var conversationID: Swift.String
  public var type: AtomicXCore.ConversationType?
  public var groupType: AtomicXCore.GroupType?
  public var avatarURL: Swift.String?
  public var title: Swift.String?
  public var lastMessage: AtomicXCore.MessageInfo?
  public var draft: Swift.String?
  public var timestamp: Swift.Int
  public var unreadCount: Swift.Int
  public var isPinned: Swift.Bool
  public var orderKey: Swift.UInt
  public var receiveOption: AtomicXCore.ConversationReceiveOption
  public init(conversationID: Swift.String)
  public static func == (lhs: AtomicXCore.ConversationInfo, rhs: AtomicXCore.ConversationInfo) -> Swift.Bool
  public typealias ID = Swift.String
}
public struct ConversationFetchOption {
  public var type: AtomicXCore.ConversationType
  public var count: Swift.UInt
  public init()
}
@_hasMissingDesignatedInitializers public class ConversationListState {
  public var conversationList: [AtomicXCore.ConversationInfo]
  public var hasMoreConversation: Swift.Bool
  public var totalUnreadCount: Swift.UInt
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ConversationListStore : ObjectiveC.NSObject {
  public var state: AtomicXCore.StatePublisher<AtomicXCore.ConversationListState>
  public static func create() -> AtomicXCore.ConversationListStore
  public func fetchConversationList(_ option: AtomicXCore.ConversationFetchOption, completion: AtomicXCore.CompletionClosure?)
  public func fetchMoreConversationList(completion: AtomicXCore.CompletionClosure?)
  public func fetchConversationInfo(_ conversationID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func pinConversation(_ conversationID: Swift.String, pin: Swift.Bool, completion: AtomicXCore.CompletionClosure?)
  public func muteConversation(_ conversationID: Swift.String, mute: Swift.Bool, completion: AtomicXCore.CompletionClosure?)
  public func deleteConversation(_ conversationID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func setConversationDraft(_ conversationID: Swift.String, draft: Swift.String?, completion: AtomicXCore.CompletionClosure?)
  public func markConversationUnread(_ conversationID: Swift.String, unread: Swift.Bool, completion: AtomicXCore.CompletionClosure?)
  public func clearConversationMessages(_ conversationID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func clearConversationUnreadCount(_ conversationID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func getConversationTotalUnreadCount(completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
public struct ErrorInfo : Swift.Error {
  public let code: Swift.Int
  public let message: Swift.String
  public init(code: Swift.Int, message: Swift.String)
}
public typealias CompletionClosure = (Swift.Result<Swift.Void, AtomicXCore.ErrorInfo>) -> Swift.Void
public class StatePublisher<State> : Combine.ObservableObject {
  public typealias StatePublisherUpdateClosure = (inout State) -> Swift.Void
  @Combine.Published @_projectedValueProperty($value) public var value: State {
    get
  }
  public var $value: Combine.Published<State>.Publisher {
    get
  }
  public init(initialState: State)
  public func subscribe<Value>(_ selector: AtomicXCore.StatePublisherSelector<State, Value>) -> Combine.AnyPublisher<Value, Swift.Never> where Value : Swift.Equatable
  public func subscribe<Value>(_ selector: AtomicXCore.StatePublisherSelector<State, Value>) -> Combine.AnyPublisher<Value, Swift.Never>
  public func subscribe() -> Combine.AnyPublisher<State, Swift.Never>
  public typealias ObjectWillChangePublisher = Combine.ObservableObjectPublisher
  @objc deinit
}
public protocol StatePropertySelector {
  associatedtype State
  associatedtype Value
  func map(_ state: Self.State) -> Self.Value
}
public class StatePublisherSelector<State, Value> : AtomicXCore.StatePropertySelector {
  convenience public init(keyPath: Swift.KeyPath<State, Value>)
  public init(projector: @escaping (State) -> Value)
  public func map(_ state: State) -> Value
  @objc deinit
}
extension AtomicXCore.StatePublisherSelector {
  public func setResult(value: Value, forStateHash stateHash: Foundation.UUID)
  public func map(_ state: State, stateHash: Foundation.UUID) -> Value
}
public enum DeviceError : Swift.Int {
  case noError
  case noDeviceDetected
  case noSystemPermission
  case notSupportCapture
  case occupiedError
  case unknownError
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum DeviceStatus : Swift.Int {
  case off
  case on
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum AudioRoute : Swift.Int {
  case speakerphone
  case earpiece
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum VideoQuality : Swift.UInt {
  case quality360P
  case quality540P
  case quality720P
  case quality1080P
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public enum NetworkQuality : Swift.UInt {
  case unknown
  case excellent
  case good
  case poor
  case bad
  case veryBad
  case down
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public struct NetworkInfo {
  public var userID: Swift.String
  public var quality: AtomicXCore.NetworkQuality
  public var upLoss: Swift.UInt32
  public var downLoss: Swift.UInt32
  public var delay: Swift.UInt32
}
public enum MirrorType : Swift.UInt {
  case auto
  case enable
  case disable
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public struct DeviceState {
  public var microphoneStatus: AtomicXCore.DeviceStatus
  public var microphoneLastError: AtomicXCore.DeviceError
  public var captureVolume: Swift.Int
  public var currentMicVolume: Swift.Int
  public var outputVolume: Swift.Int
  public var cameraStatus: AtomicXCore.DeviceStatus
  public var cameraLastError: AtomicXCore.DeviceError
  public var isFrontCamera: Swift.Bool
  public var localMirrorType: AtomicXCore.MirrorType
  public var localVideoQuality: AtomicXCore.VideoQuality
  public var currentAudioRoute: AtomicXCore.AudioRoute
  public var screenStatus: AtomicXCore.DeviceStatus
  public var networkInfo: AtomicXCore.NetworkInfo
  public init()
}
@_hasMissingDesignatedInitializers public class DeviceStore {
  public static let shared: AtomicXCore.DeviceStore
  public var state: AtomicXCore.StatePublisher<AtomicXCore.DeviceState> {
    get
  }
  public func openLocalMicrophone(completion: AtomicXCore.CompletionClosure?)
  public func closeLocalMicrophone()
  public func setOutputVolume(_ volume: Swift.Int)
  public func setAudioRoute(_ route: AtomicXCore.AudioRoute)
  public func openLocalCamera(isFront: Swift.Bool, completion: AtomicXCore.CompletionClosure?)
  public func closeLocalCamera()
  public func switchCamera(isFront: Swift.Bool)
  public func switchMirror(mirrorType: AtomicXCore.MirrorType)
  public func updateVideoQuality(_ quality: AtomicXCore.VideoQuality)
  public func startScreenShare(appGroup: Swift.String)
  public func stopScreenShare()
  public func setCaptureVolume(volume: Swift.Int)
  public func reset()
  @objc deinit
}
public struct Gift {
  public let giftID: Swift.String
  public let name: Swift.String
  public let desc: Swift.String
  public let iconURL: Swift.String
  public let resourceURL: Swift.String
  public let level: Swift.UInt
  public let coins: Swift.UInt
  public let extensionInfo: [Swift.String : Swift.String]
}
public struct GiftCategory {
  public let categoryID: Swift.String
  public let name: Swift.String
  public let desc: Swift.String
  public let extensionInfo: [Swift.String : Swift.String]
  public let giftList: [AtomicXCore.Gift]
}
public struct GiftState {
  public var usableGifts: [AtomicXCore.GiftCategory]
}
public enum GiftEvent {
  case onReceiveGift(liveID: Swift.String, gift: AtomicXCore.Gift, count: Swift.UInt8, sender: AtomicXCore.LiveUserInfo)
}
@_hasMissingDesignatedInitializers public class GiftStore {
  public static func create(liveID: Swift.String) -> AtomicXCore.GiftStore
  public var state: AtomicXCore.StatePublisher<AtomicXCore.GiftState> {
    get
  }
  public var giftEventPublisher: Combine.PassthroughSubject<AtomicXCore.GiftEvent, Swift.Never> {
    get
  }
  public func setLanguage(_ language: Swift.String)
  public func refreshUsableGifts(completion: AtomicXCore.CompletionClosure?)
  public func sendGift(giftID: Swift.String, count: Swift.UInt, completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
public enum GroupType : Swift.String, Swift.CaseIterable {
  case work
  case publicGroup
  case meeting
  case avChatRoom
  case community
  public init?(rawValue: Swift.String)
  public typealias AllCases = [AtomicXCore.GroupType]
  public typealias RawValue = Swift.String
  nonisolated public static var allCases: [AtomicXCore.GroupType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public enum GroupMemberRole : Swift.Int {
  case all
  case member
  case admin
  case owner
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct GroupMember : Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public var userID: Swift.String
  public var nickname: Swift.String?
  public var avatarURL: Swift.String?
  public var nameCard: Swift.String?
  public var role: AtomicXCore.GroupMemberRole
  public var muteUntil: Swift.UInt
  public var isMuted: Swift.Bool {
    get
  }
  public init(userID: Swift.String)
  public typealias ID = Swift.String
}
public enum GroupJoinOption : Swift.Int {
  case forbid
  case auth
  case any
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct GroupSettingState {
  public var avatarURL: Swift.String
  public var isNotDisturb: Swift.Bool
  public var isPinned: Swift.Bool
  public var groupType: AtomicXCore.GroupType
  public var groupName: Swift.String
  public var notice: Swift.String
  public var isAllMuted: Swift.Bool
  public var groupOwner: AtomicXCore.GroupMember?
  public var allMembers: [AtomicXCore.GroupMember]
  public var currentUserRole: AtomicXCore.GroupMemberRole
  public var selfNameCard: Swift.String?
  public var memberCount: Swift.UInt
  public var joinGroupApprovalType: AtomicXCore.GroupJoinOption
  public var inviteToGroupApprovalType: AtomicXCore.GroupJoinOption
  public var hasMoreGroupMembers: Swift.Bool
}
@objc @_hasMissingDesignatedInitializers public class GroupSettingStore : ObjectiveC.NSObject {
  public var groupID: Swift.String
  public var state: AtomicXCore.StatePublisher<AtomicXCore.GroupSettingState>
  public static func create(groupID: Swift.String) -> AtomicXCore.GroupSettingStore
  public func fetchGroupInfo(completion: AtomicXCore.CompletionClosure?)
  public func fetchSelfMemberInfo(completion: AtomicXCore.CompletionClosure?)
  public func fetchGroupMemberList(role: AtomicXCore.GroupMemberRole, completion: AtomicXCore.CompletionClosure?)
  public func fetchMoreGroupMemberList(completion: AtomicXCore.CompletionClosure?)
  public func updateGroupProfile(name: Swift.String?, notice: Swift.String?, avatar: Swift.String?, completion: AtomicXCore.CompletionClosure?)
  public func setGroupJoinOption(option: AtomicXCore.GroupJoinOption, completion: AtomicXCore.CompletionClosure?)
  public func setGroupInviteOption(option: AtomicXCore.GroupJoinOption, completion: AtomicXCore.CompletionClosure?)
  public func addGroupMember(userIDList: [Swift.String], completion: AtomicXCore.CompletionClosure?)
  public func deleteGroupMember(members: [AtomicXCore.GroupMember], completion: AtomicXCore.CompletionClosure?)
  public func changeGroupOwner(newOwnerID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func setGroupMemberRole(userID: Swift.String, role: AtomicXCore.GroupMemberRole, completion: AtomicXCore.CompletionClosure?)
  public func setGroupMemberMuteTime(userID: Swift.String, time: Swift.UInt, completion: AtomicXCore.CompletionClosure?)
  public func setMuteAllMembers(value: Swift.Bool, completion: AtomicXCore.CompletionClosure?)
  public func setSelfGroupNameCard(nameCard: Swift.String?, completion: AtomicXCore.CompletionClosure?)
  public func dismissGroup(completion: AtomicXCore.CompletionClosure?)
  public func quitGroup(completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
public struct LikeState {
  public var totalLikeCount: Swift.UInt
}
public enum LikeEvent {
  case onReceiveLikesMessage(liveID: Swift.String, totalLikesReceived: Swift.UInt, sender: AtomicXCore.LiveUserInfo)
}
@_hasMissingDesignatedInitializers public class LikeStore {
  public static func create(liveID: Swift.String) -> AtomicXCore.LikeStore
  public var state: AtomicXCore.StatePublisher<AtomicXCore.LikeState> {
    get
  }
  public var likeEventPublisher: Combine.PassthroughSubject<AtomicXCore.LikeEvent, Swift.Never> {
    get
  }
  public func sendLike(count: Swift.UInt = 1, completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
public enum Role : Swift.Int {
  case owner
  case admin
  case generalUser
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct LiveUserInfo {
  public var userID: Swift.String
  public var userName: Swift.String
  public var avatarURL: Swift.String
  public init()
}
public struct LiveAudienceState {
  public var audienceList: [AtomicXCore.LiveUserInfo]
  public var audienceCount: Swift.UInt
  public init()
}
public enum LiveAudienceEvent {
  case onAudienceJoined(audience: AtomicXCore.LiveUserInfo)
  case onAudienceLeft(audience: AtomicXCore.LiveUserInfo)
}
@_hasMissingDesignatedInitializers public class LiveAudienceStore {
  public static func create(liveID: Swift.String) -> AtomicXCore.LiveAudienceStore
  public var state: AtomicXCore.StatePublisher<AtomicXCore.LiveAudienceState> {
    get
  }
  public var liveAudienceEventPublisher: Combine.PassthroughSubject<AtomicXCore.LiveAudienceEvent, Swift.Never> {
    get
  }
  public func fetchAudienceList(completion: AtomicXCore.CompletionClosure?)
  public func setAdministrator(userID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func revokeAdministrator(userID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func kickUserOutOfRoom(userID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func disableSendMessage(userID: Swift.String, isDisable: Swift.Bool, completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
extension AtomicXCore.LiveUserInfo : Swift.Equatable {
  public static func == (lhs: AtomicXCore.LiveUserInfo, rhs: AtomicXCore.LiveUserInfo) -> Swift.Bool
}
public enum CoreViewType {
  case pushView
  case playView
  public static func == (a: AtomicXCore.CoreViewType, b: AtomicXCore.CoreViewType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public enum ViewLayer : Swift.Int {
  case foreground
  case background
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol VideoViewDelegate {
  @objc func createCoGuestView(seatInfo: RTCRoomEngine.TUISeatFullInfo, viewLayer: AtomicXCore.ViewLayer) -> UIKit.UIView?
  @objc func createCoHostView(seatInfo: RTCRoomEngine.TUISeatFullInfo, viewLayer: AtomicXCore.ViewLayer) -> UIKit.UIView?
  @objc func createBattleView(battleUser: RTCRoomEngine.TUIBattleUser) -> UIKit.UIView?
  @objc func createBattleContainerView() -> UIKit.UIView?
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor @preconcurrency public class LiveCoreView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency required public init(viewType: AtomicXCore.CoreViewType, frame: CoreFoundation.CGRect = .zero)
  @objc deinit
  @_Concurrency.MainActor @preconcurrency weak public var videoViewDelegate: (any AtomicXCore.VideoViewDelegate)?
}
extension AtomicXCore.LiveCoreView {
  @_Concurrency.MainActor public func setLiveID(_ liveID: Swift.String)
  @_Concurrency.MainActor @preconcurrency public func startPreviewLiveStream(roomId: Swift.String, isMuteAudio: Swift.Bool, onPlaying: RTCRoomEngine.TUIPlayOnPlayingBlock? = nil, onLoading: RTCRoomEngine.TUIPlayOnLoadingBlock? = nil, onError: RTCRoomEngine.TUIPlayOnErrorBlock? = nil)
  @_Concurrency.MainActor @preconcurrency public func stopPreviewLiveStream(roomId: Swift.String)
  @_Concurrency.MainActor @preconcurrency public static func callExperimentalAPI(_ jsonStr: Swift.String)
}
@available(*, deprecated)
extension AtomicXCore.LiveCoreView {
  @_Concurrency.MainActor @preconcurrency public func startLiveStream(liveInfo: RTCRoomEngine.TUILiveInfo, onSuccess: @escaping RTCRoomEngine.TUILiveInfoBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func startLiveStream(roomInfo: RTCRoomEngine.TUIRoomInfo, onSuccess: @escaping RTCRoomEngine.TUIRoomInfoBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func stopLiveStream(onSuccess: @escaping RTCRoomEngine.TUIStopLiveBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func stopLiveStream(onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func joinLiveStream(roomId: Swift.String, onSuccess: @escaping RTCRoomEngine.TUILiveInfoBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func joinLiveStream(roomId: Swift.String, onSuccess: @escaping RTCRoomEngine.TUIRoomInfoBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func leaveLiveStream(onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
}
@available(*, deprecated)
extension AtomicXCore.LiveCoreView {
  @_Concurrency.MainActor @preconcurrency public func startCamera(useFrontCamera: Swift.Bool, onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func switchCamera(isFront: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func stopCamera()
  @_Concurrency.MainActor @preconcurrency public func enableMirror(enable: Swift.Bool)
  @_Concurrency.MainActor @preconcurrency public func startMicrophone(onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func muteMicrophone()
  @_Concurrency.MainActor @preconcurrency public func unmuteMicrophone(onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func stopMicrophone()
}
@available(*, deprecated)
extension AtomicXCore.LiveCoreView {
  @_Concurrency.MainActor @preconcurrency public func requestIntraRoomConnection(userId: Swift.String, timeOut: Swift.Int, openCamera: Swift.Bool, seatIndex: Swift.Int = -1, onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func cancelIntraRoomConnection(userId: Swift.String, onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func respondIntraRoomConnection(userId: Swift.String, isAccepted: Swift.Bool, onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func disconnectUser(userId: Swift.String, onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func terminateIntraRoomConnection()
}
@available(*, deprecated)
extension AtomicXCore.LiveCoreView {
  @_Concurrency.MainActor @preconcurrency public func requestCrossRoomConnection(roomId: Swift.String, timeOut: Swift.Int, onSuccess: @escaping ((RTCRoomEngine.TUIConnectionCode?) -> Swift.Void), onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func cancelCrossRoomConnection(roomId: Swift.String, onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func respondToCrossRoomConnection(roomId: Swift.String, isAccepted: Swift.Bool, onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func terminateCrossRoomConnection()
  @_Concurrency.MainActor @preconcurrency public func registerConnectionObserver(observer: any AtomicXCore.ConnectionObserver)
  @_Concurrency.MainActor @preconcurrency public func unregisterConnectionObserver(observer: any AtomicXCore.ConnectionObserver)
  @_Concurrency.MainActor @preconcurrency public func setLocalVideoMuteImage(bigImage: UIKit.UIImage?, smallImage: UIKit.UIImage?)
}
@available(*, deprecated)
extension AtomicXCore.LiveCoreView {
  @_Concurrency.MainActor @preconcurrency public func registerBattleObserver(observer: any AtomicXCore.BattleObserver)
  @_Concurrency.MainActor @preconcurrency public func unregisterBattleObserver(observer: any AtomicXCore.BattleObserver)
  @_Concurrency.MainActor @preconcurrency public func requestBattle(config: RTCRoomEngine.TUIBattleConfig, userIdList: [Swift.String], timeout: Foundation.TimeInterval, onSuccess: @escaping AtomicXCore.TUIBattleRequestBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func cancelBattle(battleId: Swift.String, userIdList: [Swift.String], onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func respondToBattle(battleId: Swift.String, isAccepted: Swift.Bool, onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
  @_Concurrency.MainActor @preconcurrency public func terminateBattle(battleId: Swift.String, onSuccess: @escaping RTCRoomEngine.TUISuccessBlock, onError: @escaping RTCRoomEngine.TUIErrorBlock)
}
@available(*, deprecated)
extension AtomicXCore.LiveCoreView {
  @_Concurrency.MainActor @preconcurrency public func subscribeState<State, Value>(_ selector: AtomicXCore.StatePublisherSelector<State, Value>) -> Combine.AnyPublisher<Value, Swift.Never>
  @_Concurrency.MainActor @preconcurrency public func getState<T>() -> T where T : AtomicXCore.CoreViewState
}
@available(*, deprecated)
@objc public enum LayoutMode : Swift.Int {
  case gridLayout
  case floatLayout
  case freeLayout
  public init?(rawValue: Swift.Int)
  @available(*, deprecated)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@available(*, deprecated)
@objc public protocol ConnectionObserver {
  @objc func onConnectedUsersUpdated(userList: [RTCRoomEngine.TUIUserInfo], joinList: [RTCRoomEngine.TUIUserInfo], leaveList: [RTCRoomEngine.TUIUserInfo])
  @objc func onUserConnectionRequest(inviterUser: RTCRoomEngine.TUIUserInfo)
  @objc func onUserConnectionCancelled(inviterUser: RTCRoomEngine.TUIUserInfo)
  @objc func onUserConnectionAccepted(userInfo: RTCRoomEngine.TUIUserInfo)
  @objc func onUserConnectionRejected(userInfo: RTCRoomEngine.TUIUserInfo)
  @objc func onUserConnectionTimeout(userInfo: RTCRoomEngine.TUIUserInfo)
  @objc func onUserConnectionTerminated()
  @objc func onUserConnectionExited(userInfo: RTCRoomEngine.TUIUserInfo)
  @objc func onConnectedRoomsUpdated(hostUserList: [RTCRoomEngine.TUIConnectionUser])
  @objc func onCrossRoomConnectionRequest(hostUser: RTCRoomEngine.TUIConnectionUser)
  @objc func onCrossRoomConnectionCancelled(hostUser: RTCRoomEngine.TUIConnectionUser)
  @objc func onCrossRoomConnectionAccepted(hostUser: RTCRoomEngine.TUIConnectionUser)
  @objc func onCrossRoomConnectionRejected(hostUser: RTCRoomEngine.TUIConnectionUser)
  @objc func onCrossRoomConnectionTimeout(inviter: RTCRoomEngine.TUIConnectionUser, invitee: RTCRoomEngine.TUIConnectionUser)
  @objc func onCrossRoomConnectionExited(hostUser: RTCRoomEngine.TUIConnectionUser)
  @objc func onRoomDismissed(roomId: Swift.String)
}
@available(*, deprecated)
@objc public protocol BattleObserver {
  @objc func onBattleStarted(battleInfo: RTCRoomEngine.TUIBattleInfo)
  @objc func onBattleEnded(battleInfo: RTCRoomEngine.TUIBattleInfo)
  @objc func onUserJoinBattle(battleId: Swift.String, battleUser: RTCRoomEngine.TUIBattleUser)
  @objc func onUserExitBattle(battleId: Swift.String, battleUser: RTCRoomEngine.TUIBattleUser)
  @objc func onBattleScoreChanged(battleId: Swift.String, battleUserList: [RTCRoomEngine.TUIBattleUser])
  @objc func onBattleRequestReceived(battleId: Swift.String, inviter: RTCRoomEngine.TUIBattleUser, invitee: RTCRoomEngine.TUIBattleUser)
  @objc func onBattleRequestCancelled(battleId: Swift.String, inviter: RTCRoomEngine.TUIBattleUser, invitee: RTCRoomEngine.TUIBattleUser)
  @objc func onBattleRequestTimeout(battleId: Swift.String, inviter: RTCRoomEngine.TUIBattleUser, invitee: RTCRoomEngine.TUIBattleUser)
  @objc func onBattleRequestAccept(battleId: Swift.String, inviter: RTCRoomEngine.TUIBattleUser, invitee: RTCRoomEngine.TUIBattleUser)
  @objc func onBattleRequestReject(battleId: Swift.String, inviter: RTCRoomEngine.TUIBattleUser, invitee: RTCRoomEngine.TUIBattleUser)
}
@objc @_inheritsConvenienceInitializers @available(*, deprecated)
@objcMembers public class CoHostUser : ObjectiveC.NSObject {
  @objc public var connectionUser: RTCRoomEngine.TUIConnectionUser
  @objc public var hasAudioStream: Swift.Bool
  @objc public var hasVideoStream: Swift.Bool
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(*, deprecated)
@objcMembers public class BattleUserViewModel : ObjectiveC.NSObject {
  @objc public var battleUser: RTCRoomEngine.TUIBattleUser
  @objc public var rect: CoreFoundation.CGRect
  @objc override dynamic public init()
  @objc deinit
}
@available(*, deprecated)
@objc public class UserInfoModifyFlag : ObjectiveC.NSObject, Swift.OptionSet {
  final public let rawValue: Swift.UInt
  @objc public static let none: AtomicXCore.UserInfoModifyFlag
  @objc public static let userRole: AtomicXCore.UserInfoModifyFlag
  @objc public static let nameCard: AtomicXCore.UserInfoModifyFlag
  @objc public static let hasVideoStream: AtomicXCore.UserInfoModifyFlag
  @objc public static let hasAudioStream: AtomicXCore.UserInfoModifyFlag
  required public init(rawValue: Swift.UInt)
  @available(*, deprecated)
  public typealias ArrayLiteralElement = AtomicXCore.UserInfoModifyFlag
  @available(*, deprecated)
  public typealias Element = AtomicXCore.UserInfoModifyFlag
  @available(*, deprecated)
  public typealias RawValue = Swift.UInt
  @objc deinit
}
@available(*, deprecated)
public typealias TUIBattleRequestBlock = (Swift.String, [RTCRoomEngine.TUIBattleUser]) -> Swift.Void
extension AtomicXCore.LiveCoreView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didMoveToWindow()
}
@available(*, deprecated)
public protocol CoreViewState {
  init()
}
@available(*, deprecated)
public struct RoomState : AtomicXCore.CoreViewState {
  public var roomId: Swift.String
  public var ownerInfo: RTCRoomEngine.TUIUserInfo
  public var seatLayoutTemplateId: Swift.Int
  public var maxCoGuestCount: Swift.Int
  public var keepOwnerOnSeat: Swift.Bool
  public init()
}
@available(*, deprecated)
public struct UserState : AtomicXCore.CoreViewState {
  public var selfInfo: RTCRoomEngine.TUIUserInfo
  public var hasAudioStreamUserList: Swift.Set<Swift.String>
  public var hasVideoStreamUserList: Swift.Set<Swift.String>
  public init()
}
@available(*, deprecated)
public struct ErrorState : AtomicXCore.CoreViewState {
  public var errorInfo: (code: RTCRoomEngine.TUIError, message: Swift.String)?
  public init()
}
@available(*, deprecated)
public struct LayoutState : AtomicXCore.CoreViewState {
  public var videoLayoutMode: AtomicXCore.LayoutMode
  public var isShowEmptySeat: Swift.Bool
  public init()
}
@available(*, deprecated)
public struct MediaState : AtomicXCore.CoreViewState {
  public var isMicrophoneOpened: Swift.Bool
  public var isMicrophoneMuted: Swift.Bool
  public var isCameraOpened: Swift.Bool
  public var isFrontCamera: Swift.Bool
  public var isMirrorEnabled: Swift.Bool
  public var smallMuteImage: UIKit.UIImage?
  public var bigMuteImage: UIKit.UIImage?
  public init()
}
public enum TakeSeatMode {
  case free
  case apply
  public static func == (a: AtomicXCore.TakeSeatMode, b: AtomicXCore.TakeSeatMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct LiveInfo {
  public var liveID: Swift.String
  public var liveName: Swift.String
  public var notice: Swift.String
  public var isMessageDisable: Swift.Bool
  public var isPublicVisible: Swift.Bool
  public var isSeatEnabled: Swift.Bool
  public var keepOwnerOnSeat: Swift.Bool
  public var maxSeatCount: Swift.Int
  public var seatMode: AtomicXCore.TakeSeatMode
  public var seatLayoutTemplateID: Swift.UInt
  public var coverURL: Swift.String
  public var backgroundURL: Swift.String
  public var categoryList: [Foundation.NSNumber]
  public var activityStatus: Swift.Int
  public var liveOwner: AtomicXCore.LiveUserInfo {
    get
  }
  public var createTime: Swift.Int {
    get
  }
  public var totalViewerCount: Swift.Int
  public var isGiftEnabled: Swift.Bool
  public var metaData: [Swift.String : Swift.String]
  public init()
  public var isEmpty: Swift.Bool {
    get
  }
  public struct ModifyFlag : Swift.OptionSet {
    public let rawValue: Swift.UInt
    public static let none: AtomicXCore.LiveInfo.ModifyFlag
    public static let liveName: AtomicXCore.LiveInfo.ModifyFlag
    public static let notice: AtomicXCore.LiveInfo.ModifyFlag
    public static let isMessageDisable: AtomicXCore.LiveInfo.ModifyFlag
    public static let isPublicVisible: AtomicXCore.LiveInfo.ModifyFlag
    public static let seatMode: AtomicXCore.LiveInfo.ModifyFlag
    public static let coverURL: AtomicXCore.LiveInfo.ModifyFlag
    public static let backgroundURL: AtomicXCore.LiveInfo.ModifyFlag
    public static let categoryList: AtomicXCore.LiveInfo.ModifyFlag
    public static let activityStatus: AtomicXCore.LiveInfo.ModifyFlag
    public static let seatLayoutTemplateID: AtomicXCore.LiveInfo.ModifyFlag
    public init(rawValue: Swift.UInt)
    public typealias ArrayLiteralElement = AtomicXCore.LiveInfo.ModifyFlag
    public typealias Element = AtomicXCore.LiveInfo.ModifyFlag
    public typealias RawValue = Swift.UInt
  }
}
public struct LiveListState {
  public var liveList: [AtomicXCore.LiveInfo]
  public var liveListCursor: Swift.String
  public var currentLive: AtomicXCore.LiveInfo
}
public enum LiveEndedReason : Swift.Int {
  case endedByHost
  case endedByServer
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum LiveKickedOutReason : Swift.Int {
  case byAdmin
  case byLoggedOnOtherDevice
  case byServer
  case forNetworkDisconnected
  case forJoinRoomStatusInvalidDuringOffline
  case forCountOfJoinedRoomsExceedLimit
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum LiveListEvent {
  case onLiveEnded(liveID: Swift.String, reason: AtomicXCore.LiveEndedReason, message: Swift.String)
  case onKickedOutOfLive(liveID: Swift.String, reason: AtomicXCore.LiveKickedOutReason, message: Swift.String)
}
public typealias LiveInfoCompletionClosure = (Swift.Result<AtomicXCore.LiveInfo, AtomicXCore.ErrorInfo>) -> Swift.Void
public typealias StopLiveCompletionClosure = (Swift.Result<RTCRoomEngine.TUILiveStatisticsData, AtomicXCore.ErrorInfo>) -> Swift.Void
public typealias MetaDataCompletionClosure = (Swift.Result<[Swift.String : Swift.String], AtomicXCore.ErrorInfo>) -> Swift.Void
@_hasMissingDesignatedInitializers public class LiveListStore {
  public static let shared: AtomicXCore.LiveListStore
  final public let state: AtomicXCore.StatePublisher<AtomicXCore.LiveListState>
  final public let liveListEventPublisher: Combine.PassthroughSubject<AtomicXCore.LiveListEvent, Swift.Never>
  public func fetchLiveList(cursor: Swift.String, count: Swift.Int, completion: AtomicXCore.CompletionClosure?)
  public func createLive(_ liveInfo: AtomicXCore.LiveInfo, completion: AtomicXCore.LiveInfoCompletionClosure?)
  public func joinLive(liveID: Swift.String, completion: AtomicXCore.LiveInfoCompletionClosure?)
  public func leaveLive(completion: AtomicXCore.CompletionClosure?)
  public func endLive(completion: AtomicXCore.StopLiveCompletionClosure?)
  public func updateLiveInfo(_ liveInfo: AtomicXCore.LiveInfo, modifyFlag: AtomicXCore.LiveInfo.ModifyFlag, completion: AtomicXCore.CompletionClosure?)
  public func queryMetaData(keys: [Swift.String], completion: AtomicXCore.MetaDataCompletionClosure?)
  public func updateLiveMetaData(_ metaData: [Swift.String : Swift.String], completion: AtomicXCore.CompletionClosure?)
  public func reset()
  @objc deinit
}
extension AtomicXCore.LiveInfo : Swift.Equatable {
  public static func == (lhs: AtomicXCore.LiveInfo, rhs: AtomicXCore.LiveInfo) -> Swift.Bool
}
public struct SeatUserInfo {
  public var userID: Swift.String
  public var userName: Swift.String
  public var avatarURL: Swift.String
  public var role: AtomicXCore.Role
  public var liveID: Swift.String
  public var microphoneStatus: AtomicXCore.DeviceStatus
  public var allowOpenMicrophone: Swift.Bool
  public var cameraStatus: AtomicXCore.DeviceStatus
  public var allowOpenCamera: Swift.Bool
}
public struct RegionInfo {
  public var x: CoreFoundation.CGFloat
  public var y: CoreFoundation.CGFloat
  public var w: CoreFoundation.CGFloat
  public var h: CoreFoundation.CGFloat
  public var zorder: Swift.Int
}
public struct SeatInfo {
  public var index: Swift.Int
  public var isLocked: Swift.Bool
  public var userInfo: AtomicXCore.SeatUserInfo
  public var region: AtomicXCore.RegionInfo
}
public struct LiveCanvas {
  public var templateID: Swift.UInt
  public var w: CoreFoundation.CGFloat
  public var h: CoreFoundation.CGFloat
}
public struct LiveSeatState {
  public var seatList: [AtomicXCore.SeatInfo]
  public var canvas: AtomicXCore.LiveCanvas
  public var speakingUsers: [Swift.String : Swift.Int]
}
public enum MoveSeatPolicy : Swift.Int {
  case abortWhenOccupied
  case forceReplace
  case swapPosition
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum DeviceControlPolicy : Swift.Int {
  case unlockOnly
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum LiveSeatEvent {
  case onLocalCameraOpenedByAdmin(policy: AtomicXCore.DeviceControlPolicy)
  case onLocalCameraClosedByAdmin
  case onLocalMicrophoneOpenedByAdmin(policy: AtomicXCore.DeviceControlPolicy)
  case onLocalMicrophoneClosedByAdmin
}
@_hasMissingDesignatedInitializers public class LiveSeatStore {
  public static func create(liveID: Swift.String) -> AtomicXCore.LiveSeatStore
  public var state: AtomicXCore.StatePublisher<AtomicXCore.LiveSeatState> {
    get
  }
  public var liveSeatEventPublisher: Combine.PassthroughSubject<AtomicXCore.LiveSeatEvent, Swift.Never> {
    get
  }
  public func takeSeat(seatIndex: Swift.Int, completion: AtomicXCore.CompletionClosure?)
  public func leaveSeat(completion: AtomicXCore.CompletionClosure? = nil)
  public func muteMicrophone()
  public func unmuteMicrophone(completion: AtomicXCore.CompletionClosure?)
  public func kickUserOutOfSeat(userID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func moveUserToSeat(userID: Swift.String, targetIndex: Swift.Int, policy: AtomicXCore.MoveSeatPolicy?, completion: AtomicXCore.CompletionClosure?)
  public func lockSeat(seatIndex: Swift.Int, completion: AtomicXCore.CompletionClosure?)
  public func unlockSeat(seatIndex: Swift.Int, completion: AtomicXCore.CompletionClosure?)
  public func closeRemoteCamera(userID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func closeRemoteMicrophone(userID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func openRemoteCamera(userID: Swift.String, policy: AtomicXCore.DeviceControlPolicy, completion: AtomicXCore.CompletionClosure?)
  public func openRemoteMicrophone(userID: Swift.String, policy: AtomicXCore.DeviceControlPolicy, completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
extension AtomicXCore.SeatUserInfo : Swift.Equatable {
  public static func == (lhs: AtomicXCore.SeatUserInfo, rhs: AtomicXCore.SeatUserInfo) -> Swift.Bool
}
extension AtomicXCore.SeatInfo : Swift.Equatable {
  public static func == (lhs: AtomicXCore.SeatInfo, rhs: AtomicXCore.SeatInfo) -> Swift.Bool
}
extension AtomicXCore.RegionInfo : Swift.Equatable {
  public static func == (lhs: AtomicXCore.RegionInfo, rhs: AtomicXCore.RegionInfo) -> Swift.Bool
}
extension AtomicXCore.LiveCanvas : Swift.Equatable {
  public static func == (lhs: AtomicXCore.LiveCanvas, rhs: AtomicXCore.LiveCanvas) -> Swift.Bool
}
public enum LoginStatus : Swift.Int {
  case unlogin
  case logined
  public static func fromV2TIMStatus(_ status: ImSDK_Plus.V2TIMLoginStatus) -> AtomicXCore.LoginStatus
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum AllowType : Swift.Int, Swift.CaseIterable {
  case allowAny
  case needConfirm
  case denyAny
  public static func fromV2TIMAllowType(_ allowType: ImSDK_Plus.V2TIMFriendAllowType) -> AtomicXCore.AllowType
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [AtomicXCore.AllowType]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [AtomicXCore.AllowType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public enum Gender : Swift.Int, Swift.CaseIterable {
  case unknown
  case male
  case female
  public static func fromV2TIMGender(_ gender: ImSDK_Plus.V2TIMGender) -> AtomicXCore.Gender
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [AtomicXCore.Gender]
  public typealias RawValue = Swift.Int
  nonisolated public static var allCases: [AtomicXCore.Gender] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
public struct UserProfile {
  public var userID: Swift.String
  public var nickname: Swift.String?
  public var avatarURL: Swift.String?
  public var selfSignature: Swift.String?
  public var gender: AtomicXCore.Gender?
  public var role: Swift.UInt32?
  public var level: Swift.UInt32?
  public var birthday: Swift.UInt32?
  public var allowType: AtomicXCore.AllowType?
  public var customInfo: [Swift.String : Foundation.Data]?
  public init(userID: Swift.String, nickname: Swift.String? = nil, avatarURL: Swift.String? = nil)
}
public struct LoginState {
  public var loginStatus: AtomicXCore.LoginStatus
  public var loginUserInfo: AtomicXCore.UserProfile?
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LoginStore : ObjectiveC.NSObject {
  public var sdkAppID: Swift.Int32
  public var state: AtomicXCore.StatePublisher<AtomicXCore.LoginState>
  public static let shared: AtomicXCore.LoginStore
  public func login(sdkAppID: Swift.Int32, userID: Swift.String, userSig: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func logout(completion: AtomicXCore.CompletionClosure?)
  public func setSelfInfo(userProfile: AtomicXCore.UserProfile, completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
public enum MessageForwardType {
  case single
  case merge
  public static func == (a: AtomicXCore.MessageForwardType, b: AtomicXCore.MessageForwardType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MessageActionStore {
  public static func create() -> AtomicXCore.MessageActionStore
  public func deleteMessage(_ message: AtomicXCore.MessageInfo, completion: AtomicXCore.CompletionClosure?)
  public func recallMessage(_ message: AtomicXCore.MessageInfo, completion: AtomicXCore.CompletionClosure?)
  public func pinMessage(_ message: AtomicXCore.MessageInfo, pin: Swift.Bool, completion: AtomicXCore.CompletionClosure?)
  public func addEmojiMessage(_ message: AtomicXCore.MessageInfo, emojiID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func removeEmojiMessage(_ message: AtomicXCore.MessageInfo, emojiID: Swift.String, completion: AtomicXCore.CompletionClosure?)
  public func sendMessageReadReceipt(_ messageList: [AtomicXCore.MessageInfo], completion: AtomicXCore.CompletionClosure?)
  public func forwardMessages(_ messageList: [AtomicXCore.MessageInfo], forwardType: AtomicXCore.MessageForwardType, conversationIDList: [Swift.String], completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MessageInputStore {
  public var conversationID: Swift.String
  public static func create(conversationID: Swift.String) -> AtomicXCore.MessageInputStore
  public func sendMessage(_ message: AtomicXCore.MessageInfo, completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
public enum MessageStatus : Swift.UInt {
  case initStatus
  case sending
  case sendSuccess
  case sendFail
  case recalled
  case deleted
  case localImported
  case violation
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public enum MessageType : Swift.UInt {
  case unknown
  case text
  case image
  case video
  case sound
  case file
  case face
  case system
  case custom
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public struct MessageReaction : Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public var reactionID: Swift.String
  public var resourcePath: Swift.String
  public var reactedByMyself: Swift.Bool
  public var totalUserCount: Swift.UInt32
  public typealias ID = Swift.String
}
public struct ReplyMessageInfo {
  public var msgID: Swift.String?
  public var msgSender: Swift.String?
  public var msgAbstract: Swift.String?
  public var msgStatus: AtomicXCore.MessageStatus?
  public var messageType: AtomicXCore.MessageType?
  public var messageBody: AtomicXCore.MessageBody?
}
public enum SystemMessageInfo {
  case unknown
  case joinGroup(groupID: Swift.String, joinMember: Swift.String)
  case inviteToGroup(groupID: Swift.String, inviter: Swift.String, inviteesShowName: Swift.String)
  case quitGroup(groupID: Swift.String, quitMember: Swift.String)
  case kickedFromGroup(groupID: Swift.String, kickOperator: Swift.String, kickedMembersShowName: Swift.String)
  case setGroupAdmin(groupID: Swift.String, setAdminOperator: Swift.String, setAdminMembersShowName: Swift.String)
  case cancelGroupAdmin(groupID: Swift.String, cancelAdminOperator: Swift.String, cancelAdminMembersShowName: Swift.String)
  case changeGroupName(groupID: Swift.String, groupNameOperator: Swift.String, groupName: Swift.String)
  case changeGroupAvatar(groupID: Swift.String, groupAvatarOperator: Swift.String, groupAvatar: Swift.String)
  case changeGroupNotification(groupID: Swift.String, groupNotificationOperator: Swift.String, groupNotification: Swift.String)
  case changeGroupIntroduction(groupID: Swift.String, groupIntroductionOperator: Swift.String, groupIntroduction: Swift.String)
  case changeGroupOwner(groupID: Swift.String, groupOwnerOperator: Swift.String, groupOwner: Swift.String)
  case changeGroupMuteAll(groupID: Swift.String, groupMuteAllOperator: Swift.String, isMuteAll: Swift.Bool)
  case changeJoinGroupApproval(groupID: Swift.String, groupJoinApprovalOperator: Swift.String, groupJoinOption: AtomicXCore.GroupJoinOption)
  case changeInviteToGroupApproval(groupID: Swift.String, groupInviteApprovalOperator: Swift.String, groupInviteOption: AtomicXCore.GroupJoinOption)
  case muteGroupMember(groupID: Swift.String, muteGroupMemberOperator: Swift.String, isSelfMuted: Swift.Bool, mutedGroupMembersShowName: Swift.String, muteTime: Swift.Int)
  case pinGroupMessage(groupID: Swift.String, pinGroupMessageOperator: Swift.String)
  case unpinGroupMessage(groupID: Swift.String, unpinGroupMessageOperator: Swift.String)
  case recallMessage(groupID: Swift.String, recallMessageOperator: Swift.String, isRecalledBySelf: Swift.Bool, isInGroup: Swift.Bool, recallReason: Swift.String)
}
public struct CustomMessageInfo {
  public var data: Foundation.Data?
  public var description: Swift.String?
  public var extensionInfo: Swift.String?
  public init()
}
public struct MessageInfo : Swift.Identifiable {
  public var id: Swift.String {
    get
  }
  public var msgID: Swift.String?
  public var sender: Swift.String?
  public var isSelf: Swift.Bool
  public var receiver: Swift.String?
  public var groupID: Swift.String?
  public var timestamp: Foundation.Date?
  public var status: AtomicXCore.MessageStatus
  public var progress: Swift.Int
  public var needReadReceipt: Swift.Bool
  public var messageType: AtomicXCore.MessageType
  public var messageBody: AtomicXCore.MessageBody?
  public var readCount: Swift.Int
  public var unreadCount: Swift.Int
  public var reactions: [AtomicXCore.MessageReaction]
  public var replyMessageInfo: AtomicXCore.ReplyMessageInfo?
  public var repliedMessageCount: Swift.UInt
  public var quoteMessageInfo: AtomicXCore.ReplyMessageInfo?
  public var rawMessage: ImSDK_Plus.V2TIMMessage?
  public init()
  public typealias ID = Swift.String
}
public struct MessageBody {
  public var text: Swift.String?
  public var originalImagePath: Swift.String?
  public var originalImageWidth: Swift.Int
  public var originalImageHeight: Swift.Int
  public var originalImageSize: Swift.Int
  public var thumbImagePath: Swift.String?
  public var largeImagePath: Swift.String?
  public var videoPath: Swift.String?
  public var videoType: Swift.String?
  public var videoSize: Swift.Int
  public var videoDuration: Swift.Int
  public var videoSnapshotPath: Swift.String?
  public var videoSnapshotWidth: Swift.Int
  public var videoSnapshotHeight: Swift.Int
  public var videoSnapshotSize: Swift.Int
  public var soundPath: Swift.String?
  public var soundSize: Swift.Int
  public var soundDuration: Swift.Int
  public var isSoundPlayed: Swift.Bool?
  public var filePath: Swift.String?
  public var fileName: Swift.String?
  public var fileSize: Swift.Int32
  public var faceIndex: Swift.Int
  public var faceName: Swift.String?
  public var systemMessage: [AtomicXCore.SystemMessageInfo]?
  public var customMessage: AtomicXCore.CustomMessageInfo?
  public init()
}
public enum MessageListType {
  case history
  case pinned
  case replied
  case merged
  public static func == (a: AtomicXCore.MessageListType, b: AtomicXCore.MessageListType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct MessageFetchDirection : Swift.OptionSet {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let Older: AtomicXCore.MessageFetchDirection
  public static let Newer: AtomicXCore.MessageFetchDirection
  public typealias ArrayLiteralElement = AtomicXCore.MessageFetchDirection
  public typealias Element = AtomicXCore.MessageFetchDirection
  public typealias RawValue = Swift.UInt
}
public struct MessageFilterType : Swift.OptionSet {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let All: AtomicXCore.MessageFilterType
  public static let Image: AtomicXCore.MessageFilterType
  public static let Video: AtomicXCore.MessageFilterType
  public typealias ArrayLiteralElement = AtomicXCore.MessageFilterType
  public typealias Element = AtomicXCore.MessageFilterType
  public typealias RawValue = Swift.UInt
}
public struct MessageFetchOption {
  public var message: AtomicXCore.MessageInfo?
  public var messageSeq: Swift.UInt
  public var direction: AtomicXCore.MessageFetchDirection
  public var filterType: AtomicXCore.MessageFilterType
  public var pageCount: Swift.UInt
  public init()
}
public enum MessageListChangeReason : Swift.UInt {
  case unknown
  case fetchMessages
  case fetchMoreMessages
  case sendMessage
  case recvMessage
  case deleteMessage
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public enum MessageMediaFileType : Swift.UInt {
  case thumbImage
  case largeImage
  case originalImage
  case videoSnapshot
  case video
  case sound
  case file
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
public struct MessageListState {
  public var messageList: [AtomicXCore.MessageInfo]
  public var messageListChangeReason: AtomicXCore.MessageListChangeReason
  public var hasMoreOlderMessage: Swift.Bool
  public var hasMoreNewerMessage: Swift.Bool
}
@objc @_hasMissingDesignatedInitializers public class MessageListStore : ObjectiveC.NSObject {
  public var conversationID: Swift.String
  public var state: AtomicXCore.StatePublisher<AtomicXCore.MessageListState>
  public static func create(conversationID: Swift.String, messageListType: AtomicXCore.MessageListType) -> AtomicXCore.MessageListStore
  public func fetchMessageList(with option: AtomicXCore.MessageFetchOption, completion: AtomicXCore.CompletionClosure?)
  public func fetchMoreMessageList(direction: AtomicXCore.MessageFetchDirection, completion: AtomicXCore.CompletionClosure?)
  public func downloadMessageResource(_ message: AtomicXCore.MessageInfo, resourceType: AtomicXCore.MessageMediaFileType, completion: AtomicXCore.CompletionClosure?)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor @preconcurrency public class SignalVideoView : UIKit.UIView {
  @_Concurrency.MainActor @preconcurrency @objc override dynamic public func didMoveToWindow()
  @objc deinit
}
extension AtomicXCore.AudioChangerType : Swift.Equatable {}
extension AtomicXCore.AudioChangerType : Swift.Hashable {}
extension AtomicXCore.AudioChangerType : Swift.RawRepresentable {}
extension AtomicXCore.AudioReverbType : Swift.Equatable {}
extension AtomicXCore.AudioReverbType : Swift.Hashable {}
extension AtomicXCore.AudioReverbType : Swift.RawRepresentable {}
extension AtomicXCore.BarrageType : Swift.Equatable {}
extension AtomicXCore.BarrageType : Swift.Hashable {}
extension AtomicXCore.BarrageType : Swift.RawRepresentable {}
extension AtomicXCore.BattleEndedReason : Swift.Equatable {}
extension AtomicXCore.BattleEndedReason : Swift.Hashable {}
extension AtomicXCore.BattleEndedReason : Swift.RawRepresentable {}
extension AtomicXCore.NoResponseReason : Swift.Equatable {}
extension AtomicXCore.NoResponseReason : Swift.Hashable {}
extension AtomicXCore.NoResponseReason : Swift.RawRepresentable {}
extension AtomicXCore.CoHostStatus : Swift.Equatable {}
extension AtomicXCore.CoHostStatus : Swift.Hashable {}
extension AtomicXCore.CoHostStatus : Swift.RawRepresentable {}
extension AtomicXCore.CoHostLayoutTemplate : Swift.Equatable {}
extension AtomicXCore.CoHostLayoutTemplate : Swift.Hashable {}
extension AtomicXCore.CoHostLayoutTemplate : Swift.RawRepresentable {}
extension AtomicXCore.ContactOnlineStatus : Swift.Equatable {}
extension AtomicXCore.ContactOnlineStatus : Swift.Hashable {}
extension AtomicXCore.ContactOnlineStatus : Swift.RawRepresentable {}
extension AtomicXCore.ContactType : Swift.Equatable {}
extension AtomicXCore.ContactType : Swift.Hashable {}
extension AtomicXCore.ContactType : Swift.RawRepresentable {}
extension AtomicXCore.FriendApplicationType : Swift.Equatable {}
extension AtomicXCore.FriendApplicationType : Swift.Hashable {}
extension AtomicXCore.FriendApplicationType : Swift.RawRepresentable {}
extension AtomicXCore.GroupApplicationType : Swift.Equatable {}
extension AtomicXCore.GroupApplicationType : Swift.Hashable {}
extension AtomicXCore.GroupApplicationType : Swift.RawRepresentable {}
extension AtomicXCore.GroupApplicationHandledStatus : Swift.Equatable {}
extension AtomicXCore.GroupApplicationHandledStatus : Swift.Hashable {}
extension AtomicXCore.GroupApplicationHandledStatus : Swift.RawRepresentable {}
extension AtomicXCore.GroupApplicationHandledResult : Swift.Equatable {}
extension AtomicXCore.GroupApplicationHandledResult : Swift.Hashable {}
extension AtomicXCore.GroupApplicationHandledResult : Swift.RawRepresentable {}
extension AtomicXCore.ConversationType : Swift.Equatable {}
extension AtomicXCore.ConversationType : Swift.Hashable {}
extension AtomicXCore.ConversationType : Swift.RawRepresentable {}
extension AtomicXCore.ConversationReceiveOption : Swift.Equatable {}
extension AtomicXCore.ConversationReceiveOption : Swift.Hashable {}
extension AtomicXCore.ConversationReceiveOption : Swift.RawRepresentable {}
extension AtomicXCore.DeviceError : Swift.Equatable {}
extension AtomicXCore.DeviceError : Swift.Hashable {}
extension AtomicXCore.DeviceError : Swift.RawRepresentable {}
extension AtomicXCore.DeviceStatus : Swift.Equatable {}
extension AtomicXCore.DeviceStatus : Swift.Hashable {}
extension AtomicXCore.DeviceStatus : Swift.RawRepresentable {}
extension AtomicXCore.AudioRoute : Swift.Equatable {}
extension AtomicXCore.AudioRoute : Swift.Hashable {}
extension AtomicXCore.AudioRoute : Swift.RawRepresentable {}
extension AtomicXCore.VideoQuality : Swift.Equatable {}
extension AtomicXCore.VideoQuality : Swift.Hashable {}
extension AtomicXCore.VideoQuality : Swift.RawRepresentable {}
extension AtomicXCore.NetworkQuality : Swift.Equatable {}
extension AtomicXCore.NetworkQuality : Swift.Hashable {}
extension AtomicXCore.NetworkQuality : Swift.RawRepresentable {}
extension AtomicXCore.MirrorType : Swift.Equatable {}
extension AtomicXCore.MirrorType : Swift.Hashable {}
extension AtomicXCore.MirrorType : Swift.RawRepresentable {}
extension AtomicXCore.GroupType : Swift.Equatable {}
extension AtomicXCore.GroupType : Swift.Hashable {}
extension AtomicXCore.GroupType : Swift.RawRepresentable {}
extension AtomicXCore.GroupMemberRole : Swift.Equatable {}
extension AtomicXCore.GroupMemberRole : Swift.Hashable {}
extension AtomicXCore.GroupMemberRole : Swift.RawRepresentable {}
extension AtomicXCore.GroupJoinOption : Swift.Equatable {}
extension AtomicXCore.GroupJoinOption : Swift.Hashable {}
extension AtomicXCore.GroupJoinOption : Swift.RawRepresentable {}
extension AtomicXCore.Role : Swift.Equatable {}
extension AtomicXCore.Role : Swift.Hashable {}
extension AtomicXCore.Role : Swift.RawRepresentable {}
extension AtomicXCore.CoreViewType : Swift.Equatable {}
extension AtomicXCore.CoreViewType : Swift.Hashable {}
extension AtomicXCore.ViewLayer : Swift.Equatable {}
extension AtomicXCore.ViewLayer : Swift.Hashable {}
extension AtomicXCore.ViewLayer : Swift.RawRepresentable {}
@available(*, deprecated)
extension AtomicXCore.LayoutMode : Swift.Equatable {}
@available(*, deprecated)
extension AtomicXCore.LayoutMode : Swift.Hashable {}
@available(*, deprecated)
extension AtomicXCore.LayoutMode : Swift.RawRepresentable {}
extension AtomicXCore.TakeSeatMode : Swift.Equatable {}
extension AtomicXCore.TakeSeatMode : Swift.Hashable {}
extension AtomicXCore.LiveEndedReason : Swift.Equatable {}
extension AtomicXCore.LiveEndedReason : Swift.Hashable {}
extension AtomicXCore.LiveEndedReason : Swift.RawRepresentable {}
extension AtomicXCore.LiveKickedOutReason : Swift.Equatable {}
extension AtomicXCore.LiveKickedOutReason : Swift.Hashable {}
extension AtomicXCore.LiveKickedOutReason : Swift.RawRepresentable {}
extension AtomicXCore.MoveSeatPolicy : Swift.Equatable {}
extension AtomicXCore.MoveSeatPolicy : Swift.Hashable {}
extension AtomicXCore.MoveSeatPolicy : Swift.RawRepresentable {}
extension AtomicXCore.DeviceControlPolicy : Swift.Equatable {}
extension AtomicXCore.DeviceControlPolicy : Swift.Hashable {}
extension AtomicXCore.DeviceControlPolicy : Swift.RawRepresentable {}
extension AtomicXCore.LoginStatus : Swift.Equatable {}
extension AtomicXCore.LoginStatus : Swift.Hashable {}
extension AtomicXCore.LoginStatus : Swift.RawRepresentable {}
extension AtomicXCore.AllowType : Swift.Equatable {}
extension AtomicXCore.AllowType : Swift.Hashable {}
extension AtomicXCore.AllowType : Swift.RawRepresentable {}
extension AtomicXCore.Gender : Swift.Equatable {}
extension AtomicXCore.Gender : Swift.Hashable {}
extension AtomicXCore.Gender : Swift.RawRepresentable {}
extension AtomicXCore.MessageForwardType : Swift.Equatable {}
extension AtomicXCore.MessageForwardType : Swift.Hashable {}
extension AtomicXCore.MessageStatus : Swift.Equatable {}
extension AtomicXCore.MessageStatus : Swift.Hashable {}
extension AtomicXCore.MessageStatus : Swift.RawRepresentable {}
extension AtomicXCore.MessageType : Swift.Equatable {}
extension AtomicXCore.MessageType : Swift.Hashable {}
extension AtomicXCore.MessageType : Swift.RawRepresentable {}
extension AtomicXCore.MessageListType : Swift.Equatable {}
extension AtomicXCore.MessageListType : Swift.Hashable {}
extension AtomicXCore.MessageListChangeReason : Swift.Equatable {}
extension AtomicXCore.MessageListChangeReason : Swift.Hashable {}
extension AtomicXCore.MessageListChangeReason : Swift.RawRepresentable {}
extension AtomicXCore.MessageMediaFileType : Swift.Equatable {}
extension AtomicXCore.MessageMediaFileType : Swift.Hashable {}
extension AtomicXCore.MessageMediaFileType : Swift.RawRepresentable {}
